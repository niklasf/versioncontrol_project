<?php
// $Id$
/**
 * @file
 * Version Control / Project Node Integration - Integrates nodes of any content
 * type with version control systems supported by the Version Control API.
 *
 * Copyright 2007 by Jakob Petsovits <jpetso@gmx.at>
 *
 * Distributed under the GNU General Public Licence version 2 or higher,
 * as published by the FSF on http://www.gnu.org/copyleft/gpl.html
 */
// TODO: hook into nodeapi and catch author changes of project nodes
//       (for updating the maintainer database),
//       and project node deletions (for having a delete_project() call)

// Status values for project applications.
define('VERSIONCONTROL_PROJECT_APPLICATION_PENDING',         0);
define('VERSIONCONTROL_PROJECT_APPLICATION_APPROVED',        1);
define('VERSIONCONTROL_PROJECT_APPLICATION_DECLINED',        2);
define('VERSIONCONTROL_PROJECT_APPLICATION_QUEUED',          3);
define('VERSIONCONTROL_PROJECT_APPLICATION_DISABLED',        4);
define('VERSIONCONTROL_PROJECT_APPLICATION_MIN_PASS_LENGTH', 5);

/**
 * Retrieve a set of commits for the specified repository if they match the
 * given constraints. If no single commit matches these constraints,
 * an empty array is returned.
 *
 * @param $constraints
 *   An optional array of constraints. Possible array elements handled by
 *   this module are:
 *
 *   'nids': An array of project node ids.
 *           If given, only commits for these projects will be returned.
 *   'maintainer_uids': An array of Drupal user ids. If given, the result set
 *                      will only contain commits that correspond to one of
 *                      the projects that any of the specified users maintain.
 *
 *   In addition to this module specific constraint, you can also use
 *   the constraints defined by the Version Control API:
 *
 *   'vcs': An array of strings, like array('cvs', 'svn', 'git').
 *          If given, only commits for these backends will be returned.
 *   'repo_ids': An array of repository ids. If given, only commits
 *               for the corresponding repositories will be returned.
 *   'branches': An array of strings, specified separately for each repository,
 *               like array($repo_id => array('HEAD', 'DRUPAL-5')).
 *               If given, only commits on the given branches will be returned.
 *   'paths': An array of strings (item locations), specified separately
 *            for each repository, like
 *              array($repo_id => array(
 *                '/trunk/contributions/modules/versioncontrol',
 *                '/trunk/contributions/themes/b2',
 *              )).
 *            If given, only commits that affected this item (or its children,
 *            in case the item is a directory) will be returned.
 *   'commit_id_lower': A commit id. If given, the result set will not contain
 *                      commits earlier than this lower bound. Mind that
 *                      commit ids only correspond to chronological order
 *                      within the bounds of each repository.
 *   'commit_id_upper': A commit id. If given, the result set will not contain
 *                      commits later than this upper bound. Mind that
 *                      commit ids only correspond to chronological order
 *                      within the bounds of each repository.
 *   'date_lower': A Unix timestamp. If given, the result set will not contain
 *                 commits earlier than this lower bound.
 *   'date_upper': A Unix timestamp. If given, the result set will not contain
 *                 commits later than this upper bound.
 *   'uids': An array of Drupal user ids. If given, the result set will only
 *           contain commits that correspond to any of the specified users.
 *   'usernames': An array of system-specific usernames (the ones that the
 *                revision control systems themselves get to see).
 *                Specified separately for each repository, like
 *                array($repo_id => array('dww', 'jpetso')).
 *                If given, the result set will only contain commits that
 *                correspond to any of the specified users.
 *   '[xxx]_specific': An array of VCS specific constraints. How this array
 *                     looks like is defined by the corresponding backend
 *                     module ([xxx]_backend). Other backend modules won't
 *                     get to see this constraint, so in theory you can provide
 *                     one of those for each backend in one single query.
 *
 * @return
 *   An array of commits, reversely sorted by the time of the commit.
 *   Each element contains a structured array with the following keys:
 *
 *   'commit_id': The Drupal-specific commit identifier (a simple integer)
 *                which is unique among all commits in all repositories.
 *   'repository': The repository where this commit occurred.
 *                 This is a structured array, like a single element of
 *                 what is returned by versioncontrol_get_repositories().
 *   'date': The time when the revision was committed, given as Unix timestamp.
 *   'uid': The Drupal user id of the committer.
 *   'username': The system specific VCS username of the committer.
 *   'message': The commit message.
 *   'revision': The VCS specific commit identifier, like "1.2.2.4" in CVS,
 *               "27491" in Subversion or an SHA-1 key in various distributed
 *               version control systems.
 *
 *   Additional elements may be added by specific version control system backends.
 */
function versioncontrol_project_get_commits($constraints = array()) {
  if (isset($constraints['maintainer_uids'])) {
    $paths = array();
    $projects = versioncontrol_project_get_projects_by_maintainer($constraints['maintainer_uids']);
    unset($constraints['maintainer_uids']); // no need to pass this on

    foreach ($projects as $maintainer_uid => $value) {
      foreach ($value as $nid => $project) {
        $paths[] = $project->directory;
      }
    }

    // In case the caller has also passed a 'paths' constraint, intersect this
    // with the paths determined by the 'maintainer_uid' constraint
    // so that there is a real 'AND' condition.
    if (isset($constraints['paths'])) {
      // TODO: check for the existance of PHP version array_intersect().
      $constraints['paths'] = array_intersect($paths, $constraints['paths']);
    }
  }

  if (isset($constraints['nids'])) {
    $paths = array();
    $projects = versioncontrol_project_get_projects($constraints['nids']);
    unset($constraints['nids']); // no need to pass this on

    foreach ($projects as $nid => $project) {
      $paths[] = $project['directory'];
    }

    // In case the caller has also passed a 'paths' constraint, intersect this
    // with the paths determined by the 'nids' constraint so that there is
    // a real 'AND' condition.
    if (isset($constraints['paths'])) {
      // TODO: check for the existance and PHP version of array_intersect().
      $constraints['paths'] = array_intersect($paths, $constraints['paths']);
    }
  }

  return versioncontrol_get_commits($constraints);
}


/**
 * Retrieve a list of all maintainers for each of the given project nodes.
 *
 * @param $project_nids
 *   An array of node ids for which the maintainers should be retrieved.
 *
 * @return
 *   An array containing an nid / maintainer uid mapping that looks like
 *   array($nid => array($uid1, uid2, ...), ...). If no maintainers
 *   can be found for the given nodes, an empty array is returned.
 */
function versioncontrol_project_get_maintainers($project_nids) {
  $nid_constraints = array();
  foreach ($project_nids as $nid) {
    $nid_constraints[] = "nid = '%d'";
  }

  $maintainers = array();
  $result = db_query('SELECT * FROM {versioncontrol_project_maintainers}
                      WHERE '. implode(' OR ', $nid_constraints), $project_nids);

  while ($mapping = db_fetch_object($result)) {
    if (!isset($maintainers[$mapping->nid]) {
      $maintainers[$mapping->nid] = array();
    }
    $maintainers[$mapping->nid][] = $mapping->uid;
  }
  return $maintainers;
}


/**
 * Retrieve a list of all projects for each of the given node ids, including
 * detailed project data for all of the found projects. If no list of node ids
 * is given, all existing projects will be retrieved.
 *
 * @param $project_nids
 *   An array of project node ids for which the project information
 *   should be retrieved, or NULL for all existing projects.
 *
 * @return
 *   An array of mappings between nid and project data that looks like
 *     array(
 *       $nid => array(
 *         'nid' => $nid,
 *         'repo_id' => $repo_id,
 *         'directory' => $project_directory,
 *       ),
 *       ...
 *     ).
 *   Node ids for nodes without an assigned project are discarded and
 *   don't appear in the result value. If no projects can be found,
 *   an empty array is returned.
 */
function versioncontrol_project_get_projects($project_nids = NULL) {
  if (isset($project_nids)) {
    $nid_constraints = array();
    foreach ($project_nids as $nid) {
      $nid_constraints[] = "nid = '%d'";
    }
    $result = db_query('SELECT * FROM {versioncontrol_project_projects}
                        WHERE '. implode(' OR ', $nid_constraints), $project_nids);
  }
  else {
    $result = db_query('SELECT * FROM {versioncontrol_project_projects}');
  }

  $projects = array();
  while ($project = db_fetch_array($result)) {
    $projects[$project['nid']] = $project;
  }
  return $projects;
}


/**
 * Retrieve a list of all projects for each of the given Drupal uids
 * where the corresponding user is marked as maintainer of the project node,
 * including detailed project data for all of the found projects.
 * If no list of node ids is given, all existing maintainer/project mappings
 * will be retrieved.
 *
 * @param $maintainer_uids
 *   An array of Drupal uids for which the maintained projects should be
 *   retrieved, or NULL for all existing maintainer/project mappings.
 *
 * @return
 *   An array of mappings between maintainer uid and project data that looks like
 *     array(
 *       $uid => array(
 *         $nid => array(
 *           'nid' => $nid,
 *           'repo_id' => $repo_id,
 *           'directory' => $project_directory,
 *         ),
 *         ...
 *       ),
 *       ...
 *     ).
 *   uids for users without maintainership of any project are discarded and
 *   don't appear in the result value. If no projects can be found,
 *   an empty array is returned.
 */
function versioncontrol_project_get_projects_by_maintainer($maintainer_uids = NULL) {
  if (isset($maintainer_uids)) {
    $uid_constraints = array();
    foreach ($maintainer_uids as $uid) {
      $uid_constraints[] = "m.uid = '%d'";
    }

    $result = db_query('SELECT m.mid, p.*
                        FROM {versioncontrol_project_maintainers} m
                         AND {versioncontrol_project_projects} p
                        WHERE ('. implode(' OR ', $uid_constraints) .')
                         AND m.nid = p.nid', $maintainer_uids);
  }
  else {
    $result = db_query('SELECT m.mid, p.*
                        FROM {versioncontrol_project_maintainers} m
                         AND {versioncontrol_project_projects} p
                        WHERE m.nid = p.nid');
  }

  $projects = array();
  while ($project = db_fetch_array($result)) {
    $uid = $project['uid'];
    unset($project['uid']);

    if (!isset($projects[$uid]) {
      $projects[$uid] = array();
    }
    $projects[$uid][$project['nid']] = $project;
  }
  return $projects;
}


/**
 * Retrieve the project for the given item (file or directory) in a repository.
 *
 * @param $repository
 *   The repository which contains the item.
 * @param $path
 *   The path of the item.
 *
 * @return
 *   A structured array with project data that looks like
 *     array(
 *       'nid' => $nid,
 *       'repo_id' => $repo_id,
 *       'directory' => $project_directory,
 *     ),
 *   or NULL if the item doesn't belong to any project.
 */
function versioncontrol_project_get_project_for_item($repository, $path) {
  // TODO: Can this be worded in SQL instead of retrieving all projects?
  $projects = versioncontrol_project_get_projects();

  foreach ($projects as $nid => $project) {
    if (strpos($path, $project['directory']) !== FALSE) {
      return $project;
    }
  }
  return NULL;
}


/**
 * Add or update a project. This operation will fail if the given project's nid
 * doesn't correspond to an existing node, or if another project with the same
 * project directory as the given one already exists.
 *
 * @param $project
 *   A structured array with project data that looks like
 *     array(
 *       'nid' => $nid,
 *       'repo_id' => $repo_id,
 *       'directory' => $project_directory,
 *     ).
 * @param $maintainer_uids
 *   An array of Drupal uids specifying the project maintainers. The node owner
 *   will always have maintainer status, even if not included in the uid list.
 *
 * @return
 *   TRUE if the project was added or updated successfully, or FALSE if
 *   the operation didn't succeed.
 */
function versioncontrol_project_set_project($project, $maintainer_uids = array()) {
  // Don't do this if another project with the same directory already exists.
  $existing_project = versioncontrol_project_get_project_for_item($project->directory);
  if (isset($existing_project) && $existing_project['nid'] != $project['nid']) {
    return FALSE;
  }

  // Get the project node, so we can determine the node owner.
  $node = node_load($project->nid);
  if (!isset($node->nid)) { // the node doesn't exist
    return FALSE;
  }

  // If the entry already exists, delete it
  _versioncontrol_project_delete_project($project->nid);

  db_query("INSERT INTO {versioncontrol_project_projects}
            VALUES ('%d', '%d', '%s')",
           $project->nid, $project->repo_id, $project->directory);

  _versioncontrol_project_add_maintainers($project->nid, $node->uid, $maintainer_uids);
  return TRUE;
}

/**
 * Delete a given project and its maintainer associations from the database.
 *
 * @param $project_nid
 *   The node id of the project that should be deleted.
 */
function versioncontrol_project_delete_project($project_nid) {
  // Deletion hooks, if any, will go here.
  _versioncontrol_project_delete_project($project_nid);
}

function _versioncontrol_project_delete_project($project_nid) {
  db_result(db_query("DELETE FROM {versioncontrol_project_projects}
                      WHERE nid = '%d'", $project_nid));
  db_result(db_query("DELETE FROM {versioncontrol_project_maintainers}
                      WHERE nid = '%d'", $project_nid));
}


/**
 * Assign one or more maintainers for the given project node. Any previously
 * existing maintainer entries will be replaced by the new set of maintainers.
 * This operation will fail if the given project node doesn't exist or has
 * no project assigned.
 *
 * @param $project_nid
 *   The node id of the project node.
 * @param $maintainer_uids
 *   An array of Drupal uids specifying the project maintainers. The node owner
 *   will always have maintainer status, even if not included in the uid list.
 *
 * @return
 *   TRUE if the maintainers were added or updated successfully, or FALSE if
 *   the operation didn't succeed.
 */
function versioncontrol_project_set_maintainers($project_nid, $maintainer_uids) {
  // Don't do this if there is no corresponding project entry.
  $count = db_result(db_query("SELECT COUNT(*)
                               FROM {versioncontrol_project_projects}
                               WHERE nid = '%d'", $project_nid));
  if ($count == 0) {
    return FALSE;
  }

  // Get the project node, so we can determine the node owner.
  $node = node_load($project_nid);
  if (!isset($node->nid)) { // the node doesn't exist
    return FALSE;
  }

  db_query("DELETE FROM {versioncontrol_project_maintainers}
            WHERE nid = '%d'", $project_nid);
  _versioncontrol_project_add_maintainers($project->nid, $node->uid, $maintainer_uids);
  return TRUE;
}

/**
 * Insert maintainer entries for the given project node into the database.
 *
 * @param $project_nid
 *   The node id of the project node.
 * @param $node_owner_uid
 *   The user id of the owner of the project node.
 * @param $maintainer_uids
 *   An array of Drupal uids specifying the project maintainers. The node owner
 *   will always be registered as maintainer, even if not included in this list.
 */
function _versioncontrol_project_add_maintainers($project_nid, $node_owner_uid, $maintainer_uids) {
  // always include the node owner as project maintainer
  if (!in_array($node_owner_uid, $maintainer_uids)) {
    $maintainer_uids[] = $node_owner_uid;
  }
  foreach ($maintainer_uids as $uid) {
    db_query("INSERT INTO {versioncontrol_project_maintainers}
              VALUES ('%d', '%d')", $project_nid, $uid);
  }
}
