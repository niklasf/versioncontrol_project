<?php
// $Id$
/**
 * @file
 * Version Control / Project Node Integration - Integrates nodes of any content
 * type with version control systems supported by the Version Control API.
 *
 * Copyright 2006, 2007 Derek Wright ("dww" , http://drupal.org/user/46549)
 * Copyright 2007 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */
// TODO: only return published projects by default

/**
 * Implementation of hook_menu().
 */
function versioncontrol_project_menu($may_cache) {
  global $user;
  $items = array();
  $admin_access = user_access('administer version control systems');

  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/project/versioncontrol-project',
      'title' => t('Version control / project node integration'),
      'description' => t('Specify the content types that will be integrated with version control systems, and configure how this will be done.'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('versioncontrol_project_admin'),
      'access' => $admin_access,
      'type' => MENU_NORMAL_ITEM,
    );
  }
  else {
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      // If a user is viewing a project node that they own (or the user has
      // the 'administer nodes' permission, add the 'CVS access' tab, but only
      // if the project is associated with a repository.
      $node = node_load(arg(1));
      if (isset($node->versioncontrol_project)
          && ($node->uid == $user->uid || user_access('administer nodes')))
      {
        $repo_id = $node->versioncontrol_project['repo_id'];

        if ($repo_id > 0) {
          $items[] = array(
            'path' => 'node/'. $node->nid .'/commitlog',
            'title' => t('Commits'),
            'callback' => 'versioncontrol_project_commitlog',
            'callback arguments' => array($node),
            'access' => TRUE,
            'type' => MENU_CALLBACK,
            'weight' => 4,
          );

          if (versioncontrol_is_account_approved($user->uid, $repo_id)) {
            $items[] = array(
              'path' => 'node/'. $node->nid .'/commit-access',
              'title' => t('Commit access'),
              'callback' => 'drupal_get_form',
              'callback arguments' => array('versioncontrol_project_commit_access_form', $node),
              'access' => TRUE,
              'type' => MENU_LOCAL_TASK,
              'weight' => 5,
            );
            if (is_numeric(arg(3)) && in_array(arg(3), $node->versioncontrol_project['comaintainer_uids'])) {
              $deleted_uid = arg(3);
              $items[] = array(
                'path' => 'node/'. $node->nid .'/commit-access/'. $deleted_uid .'/delete',
                'callback' => 'drupal_get_form',
                'callback arguments' => array(
                  'versioncontrol_project_commit_access_delete_confirm',
                  $node, $deleted_uid,
                ),
                'type' => MENU_CALLBACK,
                'access' => TRUE,
              );
            }
          }
        }
      }
    }
  }
  return $items;
}


/**
 * Form callback for 'admin/project/versioncontrol-project':
 * Global settings for this module.
 */
function versioncontrol_project_admin() {
  $form = array();
  $repositories = versioncontrol_get_repositories();
  $repository_options = array();

  foreach ($repositories as $repo_id => $repository) {
    if (empty($repository_options)) {
      $first_repo_id = $repo_id;
    }
    $repository_options[$repo_id] = check_plain($repository['name']);
  }

  $form['versioncontrol_project_restrict_commits'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable project-based commit restrictions'),
    '#description' => t('Restrict commit access to projects that the user maintains. (This feature requires pre-commit hook scripts that integrate with the Version Control API.)'),
    '#default_value' => variable_get('versioncontrol_project_restrict_commits', 1),
    '#weight' => -20,
  );

  $form['versioncontrol_project_content_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Project node content types'),
    '#description' => t('The content types that you specify here will be enhanced with version control capabilities.'),
    '#default_value' => versioncontrol_project_get_content_types(),
    '#options' => node_get_types('names'),
    '#weight' => -10,
  );
  // only store checked checkbox keys
  $form['array_filter'] = array(
    '#type' => 'value',
    '#value' => TRUE,
  );

  return system_settings_form($form);
}


/**
 * Implementation of hook_nodeapi():
 * Load the project array into $node->versioncontrol_project if there is
 * a project for this node, and update/delete the project when the node
 * is being deleted.
 */
function versioncontrol_project_nodeapi(&$node, $op, $arg = NULL) {
  if (in_array($node->type, versioncontrol_project_get_content_types())) {
    switch ($op) {
      case 'load':
        $project = versioncontrol_project_get_project($node->nid);
        if (isset($project)) {
          $node->versioncontrol_project = $project;
        }
        return;

      case 'update':
        if (!isset($node->versioncontrol_project)) {
          return;
        }
        if ($node->uid != $node->versioncontrol_project['owner_uid']) {
          db_query("UPDATE {versioncontrol_project_projects}
                    SET owner_uid = '%d'
                    WHERE nid = '%d'", $node->uid, $node->nid);
        }
        return;

      case 'delete':
        versioncontrol_project_delete_project($node->nid);
        return;

      default:
        return;
    }
  }
}

/**
 * Implementation of hook_form_alter():
 * Add a fieldset to the add/edit project form where the user can specify
 * the project's repository and path.
 */
function versioncontrol_project_form_alter($form_id, &$form) {
  if (isset($form['#id']) && $form['#id'] == 'node-form'
      && in_array($form['#node']->type, versioncontrol_project_get_content_types()))
  {
    $node = $form['#node'];
    $project = isset($node->versioncontrol_project) ? $node->versioncontrol_project : NULL;
    $accounts = versioncontrol_get_accounts(array('uids' => array($node->uid)));

    // Default setting: no version control integration at all
    $form['repo_id'] = array(
      '#type' => 'value',
      '#value' => 0,
    );

    // If the user doesn't have commit access to at least one repository,
    // it makes no sense to present version control integration options.
    if (empty($accounts)) {
      return;
    }

    // Retrieve the possible repository options.
    $user_repo_ids = array(); // repositories where the user has an account
    foreach ($accounts as $uid => $usernames_by_repository) {
      foreach ($usernames_by_repository as $repo_id => $username) {
        $user_repo_ids[] = $repo_id;
      }
    }
    $repositories = versioncontrol_get_repositories(array('repo_ids' => $user_repo_ids));

    $repository_options = array(0 => t('<none>'));
    foreach ($repositories as $repo_id => $repository) {
      if (empty($repository_options)) {
        $first_repo_id = $repo_id;
      }
      $repository_options[$repo_id] = check_plain($repository['name']);
    }

    if (empty($repository_options)) {
      return;
    }

    // We're ready to go, add the form elements now.
    $form['#validate']['versioncontrol_project_form_validate'] = array();

    // Need to do it this way so that we are executed before the nodeapi hook.
    // Otherwise, stuff goes wrong if the node author changes.
    $form['#submit'] = array_merge(
      array('versioncontrol_project_form_submit' => array()),
      $form['#submit']
    );

    $form['versioncontrol_project'] = array(
      '#type' => 'fieldset',
      '#title' => t('Version control integration'),
      '#collapsible' => TRUE,
      '#collapsed' => isset($project),
    );
    $form['versioncontrol_project']['new_repository'] = array(); // currently unused
    $form['versioncontrol_project']['existing_repository'] = array();

    if (count($repository_options) > 1) {
      unset($form['repo_id']);
      $form['versioncontrol_project']['existing_repository']['repo_id'] = array(
        '#type' => 'select',
        '#title' => t('Repository'),
        '#description' => t('The version control repository where this project is located.'),
        '#default_value' => isset($project) ? $project['repo_id'] : $first_repo_id,
        '#options' => $repository_options,
      );
      $form['versioncontrol_project']['project_directory'] = array(
        '#type' => 'textfield',
        '#title' => t('Project directory'),
        '#description' => t("The project's directory within the selected repository. Directory names should start with a leading slash and must be unique for each project. For example: <code>/modules/foo</code>, <code>/themes/foo</code> or <code>/translations/foo</code>. If there is no repository associated with the project, this setting should be left blank."),
        '#default_value' => isset($project) ? $project['directory'] : '',
        '#size' => 40,
        '#maxlength' => 255,
      );
    }
  }
}

/**
 * Validate the add/edit project form before it is submitted.
 */
function versioncontrol_project_form_validate($form_id, $form_values) {
  $repo_id = $form_values['repo_id'];
  $admin_access = user_access('administer version control systems');
  $project = versioncontrol_project_get_project($form_values['nid']);

  if (!$admin_access && isset($project) && $repo_id != $project['repo_id']) {
    form_set_error('repo_id', t('You do not have permission to modify the CVS repository for this project. (The repository can\'t be changed after the project has been created.)'));
    return;
  }
  if (!$repo_id) {
    // no version control integration, we don't have to validate
    return;
  }

  $repository = versioncontrol_get_repository($repo_id);

  if (!isset($repository)) {
    form_set_error('repo_id', t('You must select a valid repository.'));
    return;
  }
  if (empty($form_values['project_directory'])) {
    form_set_error('project_directory', t('You can not specify a directory if there is no repository for this project.'));
    return;
  }

  $directory = _versioncontrol_project_remove_trailing_slashes($form_values['project_directory']);

  if (!preg_match('/^[a-zA-Z0-9\/_-]+$/', $directory)) {
    form_set_error('project_directory', t("The path of the project directory can only contain letters, numbers, slashes ('/'), hyphens ('-') and underscores ('_')."));
    return;
  }

  // Don't do this if another project with the same directory already exists.
  $existing_project = versioncontrol_project_get_project_for_item($repository, $directory);
  if (isset($existing_project) && $existing_project['nid'] != $form_values['nid']) {
    form_set_error('project_directory', t('The specified project directory conflicts with that of an existing project.'));
    return;
  }

  // project.module specific. Not the most ideal place for these checks,
  // but what the hell, it doesn't hurt nobody.
  if (module_exists('project')) {
    // TODO: admin interface
    if (project_use_taxonomy() && variable_get('versioncontrol_project_dir_validate_by_type', 1)) {
      $node = node_load($form_values['nid']);
      $project_type_tid = $node->project_type;
      $tree = taxonomy_get_term($project_type_tid);

      $directory_with_slash = ($directory == '/') ? '/' : $directory .'/';
      $dir_root = variable_get('versioncontrol_project_directory_tid_'. $project_type_tid, '/');
      if ($dir_root[strlen($dir_root)-1] != '/') {
        $dir_root .= '/';
      }
      if (strpos($directory_with_slash, $dir_root) !== FALSE) {
        form_set_error('project_directory', t("The root of the project directory does not match the selected project type (%type). By default, spaces in the type name are converted to hyphens in the path, but custom mappings can also be defined.  Given the current project type, the first element of the directory path should be: %goal.", array('%type' => $tree->name, '%goal' => $dir_root)));
        return;
      }
    }

    if (variable_get('versioncontrol_project_validate_by_short_name', 1)) {
      $last_element = array_pop(explode('/', $directory));
      if ($last_element != $form_values['uri']) {
        form_set_error('project_directory', t("The last part of the project directory (%last) does not match the short project name (%short).", array('%last' => $last_element, '%short' => $form_values['uri'])));
        return;
      }
    }
  }
}

/**
 * Add or update the project data when the add/edit project form is submitted.
 */
function versioncontrol_project_form_submit($form_id, $form_values) {
  if (!$form_values['repo_id']) {
    versioncontrol_project_delete_project($form_values['nid']);
  }
  else {
    $directory = _versioncontrol_project_remove_trailing_slashes($form_values['project_directory']);
    $project = array(
      'nid' => $form_values['nid'],
      'repo_id' => $form_values['repo_id'],
      'directory' => $form_values['project_directory'],
    );
    versioncontrol_project_set_project($project);
  }
}

/**
 * Make sure the directory starts with, but does not end with a slash.
 */
function _versioncontrol_project_remove_trailing_slashes($directory) {
  $directory = trim($directory); // remove whitespace
  if (!empty($directory) && $directory != '/') {
    $directory = '/'. trim($directory, '/');
  }
  return $directory;
}


/**
 * Form callback for 'node/$nid/commit-access':
 * Overview / management of project maintainers. This is just the minimal
 * version, the real form is done in the theming function further down,
 * as we don't want to drupal_render() the "new user" textfield and the
 * "Grant access" button at this point already.
 */
function versioncontrol_project_commit_access_form($node) {
  $form = array();
  $project = $node->versioncontrol_project;
  $repository = versioncontrol_get_repository($project['repo_id']);

  drupal_set_title(t('Commit access for @title', array('@title' => $node->title)));

  if ($node->type == 'project_project') {
    project_project_set_breadcrumb($node);
  }

  $form['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  $form['repo_id'] = array(
    '#type' => 'value',
    '#value' => $project['repo_id'],
  );
  $form['maintainer_uids'] = array(
    '#type' => 'value',
    '#value' => implode(',', $project['maintainer_uids']),
  );
  // The user id for a new project co-maintainer,
  // we'll fill this in with a real value during the validation hook.
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => 0,
  );

  $form['introduction'] = array(
    '#type' => 'markup',
    '#value' => t(
      "This page controls commit access for the %title project. Unless otherwise indicated, all users listed in this table have permission to commit and tag files in this project's directory in @repository (%directory). The project owner is listed first and always has full access.", array(
        '%title' => $node->title,
        '%directory' => $project['directory'],
        '@repository' => $repository['name'],
    )),
    '#prefix' => '<p>',
    '#suffix' => '</p>',
  );

  // The actual table is created inside the '#after_build' function.
  $form['table'] = array(
    '#type' => 'markup',
    '#value' => '',
    '#node' => $node, // remember that one for the '#after_build' function
    '#after_build' => array('versioncontrol_project_commit_access_table'),
  );
  $form['table']['username'] = array(
    '#type' => 'textfield',
    //'#required' => TRUE, // already checked by the validation hook
    '#size' => 30,
    '#maxlength' => 60,
    '#autocomplete_path' => 'versioncontrol/user/autocomplete/'. $project['repo_id'],
  );
  $form['table']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Grant access'),
  );

  return $form;
}

/**
 * The maintainers table for the above commit access form,
 * constructed by means of an '#after_build' callback function.
 */
function versioncontrol_project_commit_access_table(&$form, $form_values) {
  $node = $form['#node'];
  $project = $node->versioncontrol_project;

  $rows = array();
  $header = array();
  $header[] = array('data' => t('Drupal username'), 'field' => 'name');
  $header[] = array('data' => t('Actions'));

  // The owner of the node automatically gets commit access, list this
  // user as the first row in the table, and don't allow any operations.
  $rows[] = array(
    theme('username', $node), // theme_username() only needs ->uid and ->name.
    '<span class="disabled">'. t('locked') .'</span>'
  );

  // ...and now the co-maintainers...
  foreach ($project['comaintainer_uids'] as $uid) {
    $user = user_load(array('uid' => $uid));
    if (!$user) {
      continue; // safety check, should not happen
    }

    // Indicate any maintainers whose account is no longer approved.
    if (!versioncontrol_is_account_approved($uid, $project['repo_id'])) {
      $username = '<del>'. theme('username', $user) .'</del> <em>('. t('repository access disabled') .')</em>';
    }
    else {
      $username = theme('username', $user);
    }
    $rows[] = array($username, l(
      t('Delete'), 'node/'. $node->nid .'/commit-access/'. $uid .'/delete'
    ));
  }

  // The "new user" and "Grant access" controls from the original form.
  $rows[] = array(drupal_render($form['username']), drupal_render($form['submit']));

  // The table is done, rejoice.
  $form['#value'] = theme('table', $header, $rows);

  return $form;
}

/**
 * The validation hook for the commit access form:
 * check the validity of the new project maintainer that should be added.
 */
function versioncontrol_project_commit_access_form_validate($form_id, $form_values, $form) {
  $username = $form_values['username'];
  $repo_id = $form_values['repo_id'];
  $maintainer_uids = explode(',', $form_values['maintainer_uids']);

  if (empty($username)) {
    form_set_error('username', t('You must specify a valid user name.'));
    return;
  }

  $result = db_fetch_object(db_query("SELECT name, uid FROM {users}
                                      WHERE name = '%s'", $username));

  if (!isset($result)) {
    form_set_error('username', t('%user is not a valid user on this site.', array('%user' => $username)), 'error');
    return;
  }

  $uid = $result->uid;
  $vcs_username = versioncontrol_get_account_username_for_uid($uid, $repo_id);

  if (!isset($vcs_username)) {
    $repository = versioncontrol_get_repository($repo_id);
    form_set_error('username', t('%user does not have an account in @repository.', array('%user' => $username, '@repository' => $repository['name'])), 'error');
    return;
  }
  if (in_array($uid, $maintainer_uids)) {
    form_set_error('username', t('%user already has commit access for this project.', array('%user' => $username)), 'error');
    return;
  }

  // save the uid in the form so we don't have to look it up again in
  // submit(). we also stash user, since it's not set directly when
  // using the special theme function to generate the form.
  form_set_value($form['uid'], $uid);
}

/**
 * The submit hook for the commit access form: add a new project maintainer.
 */
function versioncontrol_project_commit_access_form_submit($form_id, $form_values) {
  $nid = $form_values['nid'];
  $uid = $form_values['uid'];
  db_query("INSERT INTO {versioncontrol_project_comaintainers} (nid, uid)
            VALUES (%d, %d)", $nid, $uid);

  $user = new stdClass();
  $user->uid = $form_values['uid'];
  $user->name = $form_values['username'];
  drupal_set_message(t('Commit access has been granted to !user.', array(
    '!user' => theme('username', $user),
  )));
}

/**
 * Form callback for 'node/$nid/commit-access/$uid/delete':
 * Provide a form to confirm deletion of a user's commit access.
 */
function versioncontrol_project_commit_access_delete_confirm($node, $uid) {
  $form = array();
  $project = $node->versioncontrol_project;

  if ($node->type == 'project_project') {
    project_project_set_breadcrumb($node, array(l($node->title, 'node/'. $node->nid)));
  }

  if ($uid == $node->uid) {
    drupal_set_title(t('User is locked'));
    $form['nodelete'] = array(
      '#type' => 'markup',
      '#value' => t('You cannot delete commit access for !user because this user is the owner of the project.',
                    array('!user' => theme('username', $node))),
    );
    return $form;
  }

  $user = user_load(array('uid' => $uid));

  if (!in_array($uid, $project['comaintainer_uids'])) {
    drupal_set_title(t('User is not a maintainer'));
    $form['nodelete'] = array(
      '#type' => 'markup',
      '#value' => t('!user does not have commit access so you cannot delete that.',
                    array('!user' => theme('username', $user))),
    );
    return $form;
  }

  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  $form['uid'] = array('#type' => 'value', '#value' => $uid);

  return confirm_form($form,
    t('Are you sure you want to delete commit access for !user?',
      array('!user' => theme('username', $user))),
    'node/'. $node->nid .'/commit-access',
    t('This action cannot be undone.'),
    t('Delete'),
    t('Cancel')
  );
}

/**
 * Delete the repository when the confirmation form is submitted.
 */
function versioncontrol_project_commit_access_delete_confirm_submit($form_id, $form_values) {
  $nid = $form_values['nid'];
  $uid = $form_values['uid'];
  $user = user_load(array('uid' => $uid));
  db_query("DELETE FROM {versioncontrol_project_comaintainers}
            WHERE nid = '%d' AND uid = '%d'", $nid, $uid);
  drupal_set_message(t('Commit access for !user has been deleted.', array('!user' => theme('username', $user))));
  return 'node/'. $nid .'/commit-access';
}


/**
 * Callback for 'node/$nid/commitlog'
 */
function versioncontrol_project_commitlog($node) {
  if ($node->type == 'project_project') {
    project_project_set_breadcrumb($node, array(l($node->title, 'node/'. $node->nid)));
  }

  $_REQUEST['nids'] = (string) $node->nid;
  drupal_set_title(t('Commits for @title', array('@title' => $node->title)));
  return commitlog_page();
}



/**
 * Return all content types that are marked as "project node" types.
 */
function versioncontrol_project_get_content_types() {
  return variable_get('versioncontrol_project_content_types', array());
}

/**
 * Return a modified version of the given commit constraints that includes
 * the given project specific constraints in a way that the Version Control API
 * can understand it.
 *
 * @param $constraints
 *   The constraints array that you already prepared for passing to
 *   versioncontrol_get_commits().
 *
 * @param $project_constraints
 *   An array of project specific constraints.
 *   Possible array elements handled by this module are:
 *
 *   'nids': An array of project node ids.
 *           If given, only commits for these projects will be returned.
 *   'maintainer_uids': An array of Drupal user ids. If given, the result set
 *                      will only contain commits that correspond to one of
 *                      the projects that any of the specified users maintain.
 */
function versioncontrol_project_get_commit_constraints($constraints, $project_constraints) {
  if (isset($project_constraints['maintainer_uids'])) {
    $paths = array();
    $projects = versioncontrol_project_get_projects(array(
      'maintainer_uids' => $project_constraints['maintainer_uids'],
    ));

    foreach ($projects as $nid => $project) {
      $paths[] = $project->directory;
    }

    // In case the caller has also passed a 'paths' constraint, intersect this
    // with the paths determined by the 'maintainer_uid' constraint
    // so that there is a real 'AND' condition.
    $constraints['paths'] = isset($constraints['paths'])
                            ? array_intersect($paths, $constraints['paths'])
                            : $paths;
  }

  if (isset($project_constraints['nids'])) {
    $paths = array();
    $projects = versioncontrol_project_get_projects(array(
      'nids' => $project_constraints['nids'],
    ));

    foreach ($projects as $nid => $project) {
      $paths[] = $project['directory'];
    }

    // In case the caller has also passed a 'paths' constraint, intersect this
    // with the paths determined by the 'nids' constraint so that there is
    // a real 'AND' condition.
    $constraints['paths'] = isset($constraints['paths'])
                            ? array_intersect($paths, $constraints['paths'])
                            : $paths;
  }

  return $constraints;
}


/**
 * Convenience function to retrieve one single project by project node id.
 *
 * @return
 *   The project array for the given project node,
 *   which consists of the following elements:
 *
 *   'nid': The node id of the project node.
 *   'owner_uid': The Drupal user id of the project owner.
 *   'repo_id': The repository id of the repository where the project resides.
 *   'directory': The project directory inside the repository.
 *   'maintainer_uids': An array containing all maintainer uids, that is,
 *                      the project owner and the co-maintainers.
 *   'comaintainer_uids': An array containing all co-maintainer uids.
 *
 *   If there is no version control data for that node, NULL is returned.
 */
function versioncontrol_project_get_project($nid) {
  $projects = versioncontrol_project_get_projects(array('nids' => array($nid)));
  foreach ($projects as $nid => $project) {
    return $project;
  }
  return NULL;
}

/**
 * Convenience function to retrieve a set of projects by maintainer uid.
 *
 * @return
 *   An array of projects with the project node id as key, where each element
 *   is again a structured array that consists of the following elements:
 *
 *   'nid': The node id of the project node.
 *   'owner_uid': The Drupal user id of the project owner.
 *   'repo_id': The repository id of the repository where the project resides.
 *   'directory': The project directory inside the repository.
 *   'maintainer_uids': An array containing all maintainer uids, that is,
 *                      the project owner and the co-maintainers.
 *   'comaintainer_uids': An array containing all co-maintainer uids.
 *
 *   If the given user doesn't maintain at least one project,
 *   an empty array is returned.
 */
function versioncontrol_project_get_projects_for_maintainer($uid) {
  return versioncontrol_project_get_projects(array('maintainer_uids' => array($uid)));
}

/**
 * Retrieve a set of projects that match the given constraints.
 *
 * @param $constraints
 *   An optional array of constraints. Possible array elements are:
 *
 *   'nids': An array of project node ids. If given, only the corresponding
 *           projects will be returned.
 *   'owner_uids': An array of Drupal user ids. If given, only projects with
 *                 one of these users as project owner will be returned.
 *   'maintainer_uids': An array of Drupal user ids. If given, only projects
 *                      with at least one of these users as maintainer
 *                      will be returned.
 *
 * @return
 *   An array of projects with the project node id as key, where each element
 *   is again a structured array that consists of the following elements:
 *
 *   'nid': The node id of the project node.
 *   'owner_uid': The Drupal user id of the project owner.
 *   'repo_id': The repository id of the repository where the project resides.
 *   'directory': The project directory inside the repository.
 *   'maintainer_uids': An array containing all maintainer uids, that is,
 *                      the project owner and the co-maintainers.
 *   'comaintainer_uids': An array containing all co-maintainer uids.
 *
 *   If not a single project matches these constraints,
 *   an empty array is returned.
 */
function versioncontrol_project_get_projects($constraints = array()) {
  $and_constraints = array('p.nid > 0');
  $params = array();
  $maintainer_join = '';

  // project node constraints
  if (isset($constraints['nids'])) {
    $or_constraints = array();
    foreach ($constraints['nids'] as $nid) {
      $or_constraints[] = "p.nid = '%d'";
      $params[] = $nid;
    }
    $and_constraints[] = implode(' OR ', $or_constraints);
  }

  if (isset($constraints['owner_uids'])) {
    foreach ($constraints['owner_uids'] as $uid) {
      $or_constraints[] = "p.owner_uid = '%d'";
      $params[] = $uid;
    }
    $and_constraints[] = implode(' OR ', $or_constraints);
  }

  if (isset($constraints['maintainer_uids'])) {
    $maintainer_join = ' LEFT JOIN {versioncontrol_project_comaintainers} c
                         ON p.nid = c.nid';

    foreach ($constraints['maintainer_uids'] as $uid) {
      $or_constraints[] = "p.owner_uid = '%d'";
      $params[] = $uid;
      $or_constraints[] = "c.uid = '%d'";
      $params[] = $uid;
    }
    $and_constraints[] = implode(' OR ', $or_constraints);
  }

  $where = empty($and_constraints) ? '' : ' WHERE '. implode(' AND ', $and_constraints);

  $result = db_query('SELECT DISTINCT(p.nid), p.owner_uid, p.repo_id, p.directory
                      FROM {versioncontrol_project_projects} p'.
                      $maintainer_join . $where, $params);

  $projects = array();
  while ($project = db_fetch_object($result)) {
    $comaintainers = _versioncontrol_project_get_comaintainers($project->nid);

    $projects[$project->nid] = array(
      'nid'             => $project->nid,
      'owner_uid'       => $project->owner_uid,
      'repo_id'         => $project->repo_id,
      'directory'       => $project->directory,
      'maintainer_uids' => array_merge(
        array($project->owner_uid), $comaintainers
      ),
      'comaintainer_uids' => $comaintainers,
    );
  }
  return $projects;
}

/**
 * Retrieve the list of all maintainers for the given project.
 *
 * @param $nid
 *   The node id of the project node for which the maintainers#
 *   should be retrieved.
 *
 * @return
 *   An array of maintainer uids for the given project. There is at least
 *   one maintainer for each project (the node owner).
 */
function _versioncontrol_project_get_comaintainers($nid) {
  $result = db_query("SELECT uid
                      FROM {versioncontrol_project_comaintainers} c
                      WHERE nid = '%d'", $nid);

  $maintainers = array();
  while ($maintainer = db_fetch_object($result)) {
    $maintainers[] = $maintainer->uid;
  }
  return $maintainers;
}


/**
 * Retrieve the project for the given item (file or directory) in a repository.
 *
 * @param $repository
 *   The repository which contains the item.
 * @param $path
 *   The path of the item.
 *
 * @return
 *   The project array of the project that contains the item.
 *   It consists of the following elements:
 *
 *   'nid': The node id of the project node.
 *   'owner_uid': The Drupal user id of the project owner.
 *   'repo_id': The repository id of the repository where the project resides.
 *   'directory': The project directory inside the repository.
 *   'maintainer_uids': An array containing all maintainer uids, that is,
 *                      the project owner and the co-maintainers.
 *   'comaintainer_uids': An array containing all co-maintainer uids.
 *
 *   If the item doesn't belong to any project, NULL is returned.
 */
function versioncontrol_project_get_project_for_item($repository, $path) {
  return _versioncontrol_project_get_project_for_item($repository['repo_id'], $path);
}

function _versioncontrol_project_get_project_for_item($repo_id, $path) {
  static $projects_for_item = array();

  if (!isset($projects_for_item[$path])) { // not cached, find out now
    $current_path = $path;

    // Now, we loop over the path, using the most restrictive path first,
    // and query the database to find a matching published project node.
    while (TRUE) {
      $result = db_query("SELECT p.nid, p.owner_uid, p.repo_id, p.directory
                          FROM {versioncontrol_project_projects} p
                          WHERE p.nid > 0
                           AND p.repo_id = '%d' AND p.directory = '%s'",
                          $repo_id, $current_path);

      if ($project = db_fetch_object($result)) {
        $comaintainers = _versioncontrol_project_get_comaintainers($project->nid);

        $projects_for_item[$path] = array(
          'nid'             => $project->nid,
          'owner_uid'       => $project->owner_uid,
          'repo_id'         => $project->repo_id,
          'directory'       => $project->directory,
          'maintainer_uids' => array_merge(
            array($project->owner_uid), $comaintainers
          ),
          'comaintainer_uids' => $comaintainers,
        );
        return $projects_for_item[$path];
      }

      if ($current_path == dirname($current_path)) {
        break; // stop at the top-level directory
      }
      $current_path = dirname($current_path);
    }

    // If we didn't find it already, cache the answer as not-found
    $projects_for_item[$path] = 0;
  }
  return ($projects_for_item[$path] != 0) ? $projects_for_item[$path] : NULL;
}


/**
 * Add or update a project. This operation will fail if the given project's nid
 * doesn't correspond to an existing node.
 *
 * @param $project
 *   The project array containing the new or existing repository.
 *   In comparison to standard project arrays, the 'owner uid' and
 *   'maintainer uids' elements are disregarded, so it only needs to contain
 *   the following elements:
 *
 *   'nid': The node id of the project node.
 *   'repo_id': The repository id of the repository where the project resides.
 *   'directory': The project directory inside the repository.
 *   'comaintainer_uids': Optional. If given, the list of co-maintainer uids
 *                        will be updated with this one.
 *
 * @return
 *   TRUE if the project could be created, or FALSE if not.
 */
function versioncontrol_project_set_project($project) {
  if ($project['repo_id'] == 0) { // "don't use version control integration"
    db_query("DELETE FROM {versioncontrol_project_comaintainers}
              WHERE nid = '%d'", $project['nid']);
    db_query("INSERT INTO {versioncontrol_project_projects}
              (nid, owner_uid, repo_id, directory)
              VALUES ('%d', '%d', '%d', '%s')",
              $project['nid'], 0, 0, '');
  }

  // Get the project node, so we can determine the node owner.
  $node = node_load($project['nid']);
  if (!isset($node->nid)) { // the node doesn't exist
    return FALSE;
  }
  $project['owner_uid'] = $node->uid;

  // If the entry already exists, delete it.
  db_query("DELETE FROM {versioncontrol_project_projects}
            WHERE nid = '%d'", $project['nid']);

  db_query("INSERT INTO {versioncontrol_project_projects}
            (nid, owner_uid, repo_id, directory)
            VALUES ('%d', '%d', '%d', '%s')",
            $project['nid'], $project['owner_uid'],
            $project['repo_id'], $project['directory']);

  if (isset($project['comaintainer_uids'])) {
    // Delete the list, so we can easily insert them.
    db_query("DELETE FROM {versioncontrol_project_comaintainers}
              WHERE nid = '%d'", $project['nid']);

    // Insert each comaintainer into the database.
    foreach ($project['comaintainer_uids'] as $uid) {
      if ($uid == $project['owner_uid']) {
        continue; // the owner is not a co-maintainer
      }
      db_query("INSERT INTO {versioncontrol_project_comaintainers} (nid, uid)
                VALUES ('%d', '%d')", $project['nid'], $uid);
    }
  }

  // Insertion/update hooks, if any, will go here. (Remember to add
  // the maintainer uids to the project array if you provide a hook.)

  return TRUE;
}

/**
 * Delete all version control data (project information and
 * maintainer associations) for a given project from the database.
 * If no project with this node id exists, nothing will be done.
 *
 * @param $nid
 *   The node id of the project node whose version control data
 *   should be deleted.
 */
function versioncontrol_project_delete_project($nid) {
  $count = db_result(db_query("SELECT COUNT(*) FROM {versioncontrol_project_projects}
                               WHERE nid = '%d'", $nid));
  if (!$count) {
    return; // nothing to delete
  }

  // Deletion hooks, if any, will go here.

  db_query("DELETE FROM {versioncontrol_project_projects}
            WHERE nid = '%d'", $nid);
  db_query("DELETE FROM {versioncontrol_project_comaintainers}
            WHERE nid = '%d'", $nid);
}

/**
 * Implementation of hook_versioncontrol_commit_access():
 * Project based commit restrictions.
 *
 * @param $commit
 *   A commit array of the commit that is about to happen. As it's not
 *   committed yet, it's not yet in the database as well, which means that
 *   any commit info retrieval functions won't work on this commit array.
 *   It also means there's no 'commit_id', 'revision' and 'date' elements like
 *   in regular commit arrays. The 'message' element might or might not be set.
 * @param $commit_actions
 *   The commit actions of the above commit that is about to happen.
 *   Further information retrieval functions won't work on this array as well.
 *   Also, the 'source items' element of each action and the 'revision' element
 *   of each item in these actions might not be set.
 * @param $branch
 *   The target branch where the commit will happen (a string like 'DRUPAL-5').
 *   If the respective backend doesn't support branches,
 *   this may be NULL instead.
 *
 * @return
 *   An array with error messages (without trailing newlines) if the commit
 *   should not be allowed, or an empty array if we're indifferent,
 *   or TRUE if the commit should be allowed no matter what other
 *   commit access callbacks say.
 */
function versioncontrol_project_versioncontrol_commit_access($commit, $commit_actions, $branch = NULL) {
  if (empty($commit_actions)) {
    return array(); // no idea if this is ever going to happen, but let's be prepared
  }
  if (!variable_get('versioncontrol_project_restrict_commits', 1)) {
    return array(); // we don't need no restrictions
  }

  $error_messages = _versioncontrol_project_check_drupal_user($commit, $user);
  if (!empty($error_messages)) {
    return $error_messages;
  }

  $user_projects = versioncontrol_project_get_projects_for_maintainer($commit['uid']);

  foreach ($commit_actions as $path => $action) {
    $item = versioncontrol_get_affected_item($action);
    $is_allowed = FALSE;

    // Allow item modifications if they happen inside one of the user's projects
    foreach ($user_projects as $project) {
      $path = $item['path'];

      if ($item['type'] == VERSIONCONTROL_ITEM_DIRECTORY && $item['path'] != '/') {
        $path = $item['path'] .'/';
      }
      if (strpos($path, $project['directory'] .'/') !== FALSE) {
        $is_allowed = TRUE;
        break;
      }
    }
    if (!$is_allowed) {
      // All projects have been checked and continue has not yet been hit,
      // which means the item is outside the user's projects.
      $error_messages[] = t(
'** Access denied: !user does not have permission to commit files in:
** !directory',
        array('!user' => $user->name, '!directory' => $commit['directory'])
      ) .
      _versioncontrol_project_get_project_error_appendix(
        $commit['repository'], $item['path']
      );
      return $error_messages;
    }
  }
  return array();
}

function _versioncontrol_project_get_project_error_appendix($repository, $item_path) {
  $project = versioncontrol_project_get_project_for_item($repository, $item_path);
  if (isset($project) && $project['owner_uid'] != 0) {
    $owner = user_load(array('uid' => $project['owner_uid']));
  }
  if (!$owner) {
    return '';
  }
  return "\n" . t(
'** Please contact the owner of this project
** (!user, !user-url)
** and request to be added as a project maintainer.',
    array('!user' => $owner->name, '!user-url' => 'user/'. $owner->uid)
  );
}

/**
 * Implementation of hook_versioncontrol_branch_access():
 * Determine if the given branch may be assigned to a set of items.
 *
 * @param $branch
 *   A structured array that consists of the following elements:
 *
 *   'branch_name': The name of the target branch (a string like 'DRUPAL-6--1').
 *   'action': Specifies what is going to happen with the branch. This is
 *             VERSIONCONTROL_ACTION_ADDED if the branch is being created,
 *             VERSIONCONTROL_ACTION_MOVED if it's being renamed,
 *             or VERSIONCONTROL_ACTION_DELETED if it is slated for deletion.
 *   'uid': The Drupal user id of the committer.
 *   'username': The system specific VCS username of the committer.
 *   'repository': The repository where the branching occurs,
 *                 given as a structured array, like the return value
 *                 of versioncontrol_get_repository().
 *   'directory': The deepest-level directory in the repository that is common
 *                to all of the branched items.
 *
 * @param $branched_items
 *   An array of all items that are affected by the branching operation.
 *   Compared to standard item arrays, the ones in here don't need the
 *   'revision' element to be set and can optionally contain a 'source branch'
 *   element that specifies the original branch of this item.
 *   (For $op == 'delete', 'source branch' is never set.)
 *
 * @return
 *   An array with error messages (without trailing newlines) if the branch
 *   may not be assigned, or an empty array if we're indifferent,
 *   or TRUE if the branch may be assigned no matter what other
 *   branch access callbacks say.
 */
function versioncontrol_project_versioncontrol_branch_access($branch, $branched_items) {
  return _versioncontrol_project_branch_or_tag_access($branch, $branched_items);
}

/**
 * Implementation of hook_versioncontrol_tag_access():
 * Determine if the given tag may be assigned to a set of items.
 *
 * @param $tag
 *   A structured array that consists of the following elements:
 *
 *   'tag_name': The name of the tag (a string like 'DRUPAL-6--1-1').
 *   'action': Specifies what is going to happen with the tag. This is
 *             VERSIONCONTROL_ACTION_ADDED if the tag is being created,
 *             VERSIONCONTROL_ACTION_MOVED if it's being renamed,
 *             or VERSIONCONTROL_ACTION_DELETED if it is slated for deletion.
 *   'uid': The Drupal user id of the committer.
 *   'username': The system specific VCS username of the committer.
 *   'repository': The repository where the tagging occurs,
 *                 given as a structured array, like the return value
 *                 of versioncontrol_get_repository().
 *   'directory': The deepest-level directory in the repository that is common
 *                to all of the tagged items.
 *
 * @param $tagged_items
 *   An array of all items that are affected by the tagging operation.
 *   Compared to standard item arrays, the ones in here don't need the
 *   'revision' element to be set and can optionally contain a 'source branch'
 *   element that specifies the original branch of this item.
 *   (For $op == 'move' or $op == 'delete', 'source branch' is never set.)
 *
 * @return
 *   An array with error messages (without trailing newlines) if the tag
 *   may not be assigned, or an empty array if we're indifferent,
 *   or TRUE if the tag may be assigned no matter what other
 *   tag access callbacks say.
 */
function versioncontrol_project_versioncontrol_tag_access($tag, $tagged_items) {
  return _versioncontrol_project_branch_or_tag_access($tag, $tagged_items);
}

/**
 * Shared code between branch_access() and tag_access():
 * Disallow assigning tags or branches in directories that don't have
 * a project assigned.
 */
function _versioncontrol_project_branch_or_tag_access($branch_or_tag, $items) {
  if (!variable_get('versioncontrol_project_restrict_commits', 1)) {
    return array(); // we don't need no restrictions
  }

  $error_messages = _versioncontrol_project_check_drupal_user($branch_or_tag, $user);
  if (!empty($error_messages)) {
    return $error_messages;
  }

  $project = versioncontrol_project_get_project_for_item(
    $branch_or_tag['repository'], $branch_or_tag['directory']
  );
  if (!isset($project)) {
    $backends = versioncontrol_get_backends();
    $backend = $backends[$repository['vcs']];

    $error_messages[] = t(
      "** ERROR: no published project was found for this directory:\n".
      "** !directory\n".
      "** Please contact a !vcs administrator for help.",
      array('!directory' => $branch_or_tag['directory'], '!vcs' => $backend['name'])
    );
    return $error_messages;
  }
  // TODO: project directory based access check!
  return array();
}

/**
 * Determine if the user for the given Drupal user id exists, and return
 * an appropriate error message array.
 *
 * @param $object
 *   The commit or branch/tag operation array that should be checked.
 * @param $user
 *   A by-reference parameter that will be filled with the return value
 *   of user_load(). That is, if this function returns an empty array
 *   (no errors) then this is the user object of the committer.
 *
 * @return
 *   An empty array if the user exists, or an array filled
 *   with an error message if the user doesn't exist.
 */
function _versioncontrol_project_check_drupal_user($object, &$user) {
  if ($object['uid'] != 0) {
    $user = user_load(array('uid' => $object['uid']));
  }
  if (!$user) {
    $backends = versioncontrol_get_backends();
    $backend = $backends[$object['repository']['vcs']];

    $error_message = t(
      "** ERROR: no Drupal user matches !vcs user '!user'.\n".
      "** Please contact a !vcs administrator for help.",
      array('!vcs' => $backend['name'], '!user' => $object['username'])
    );
    return array($error_message);
  }
  return array();
}

/**
 * Implementation of hook_versioncontrol_account():
 * Delete commit access for accounts that are being deleted.
 */
function versioncontrol_project_versioncontrol_account($op, $uid, $username, $repository, $additional_data = array()) {
  if ($op == 'delete') {
    db_query("UPDATE {versioncontrol_project_projects}
              SET repo_id = '0', owner_uid = '0', directory = ''
              WHERE owner_uid = '%d'", $uid);
    db_query("DELETE FROM {versioncontrol_project_comaintainers}
              WHERE uid = '%d'", $uid);
  }
}
